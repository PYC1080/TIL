# React - 기본

## 1. 리액 프로젝트 구축하는 방법

### 1) 리액트란?

```
1. React : 페이스북에서 개발하고 관리하는 UI라이브러리. angular가 웹 애플리케이션 개발에 필요한 다수의 기능을 제공하는 것과는 대조적으로 React는 UI기능만 제공한다. React와 같은 frontend libraray or framework를 사용하는 이유는 UI를 자동으로 업데이트해 준다는 점이다. 리액트는 virtual dom을 통해서 UI를 빠르게 업데이트한다는 점이다.

2. React 제약사항
	1) 렌더 함수는 순수 함수로 작성해야 한다
	2) 컴포넌트 상탯값은 불변 객체로 관리해야 한다
```

### 2) 리액트 개발 환경 직접 구축

* 리액트 네이티브

```
리액트 네이티브 : 리액트로 안드로이드와 iOS의 네이티브 앱을 만들 수 있다. 리액트 네이티브를 이용하면 하나의 소스코드로 안드로이드와 iOS에서 동작하는 앱을 만들 수 있다. 그러나 플랫폼에 종속적인 기능을 사용하기 위해서는 플랫폼별로 코드를 작성해야 한다
```

* createElement  

```js
1. 구조 : React.createElement(component,props,...children) => ReactElement

2. 매개 변수
	1) component : 문자열이나 리액트 컴포넌트. component의 인수가 문자열이면 HTML 태그에 해당하는 돔 요소가 생성된다
    2) props : 컴포넌트가 사용하는 데이터
    3) children : 해당 컴포넌트가 감싸고 있는 내부의 컴포넌트를 가리킨다
```

* babel 

```
1. babel : 자바스크립트 코드를 변환해 주는 컴파일러. babel을 사용하면 최신 자바스크립트 문법을 지원하지 않는 환경에서도 최신 문법을 사용할 수 있다

2. babel plug-in & preset
	1) babel plug-in : 자바스크립트 파일을 변환해 주는 작업은 플러그인 단위로 이루어진다
	2) babel preset : 플러그인의 집합 
```

* webpack

```
1. webpack : 자바스크립트로 만든 프로그램을 배포하기 좋은 형태로 묶어주는 툴
```

### 3) create-react-app

* create-react-app : react로 웹 애플리케이션을 만들기 위한 환결을 제공한다

* create-react-app 개발 환경 설치

```powershell
PS ...> npx create-react-app folder_name
```

* 주요 명령어

```
1. 개발 모드 실행
	1) 명령어 : PS ...> npm start
	2) 특징 : 개발 모드로 실행하면 HMR이 동작하기 때문에 코드를 수정하면 화면에 즉시 반영된다
	3) 옵션 : https로 실행
		(1) 맥 : HTTPS=true npm start
		(2) 윈도우 : set HTTPS=true && npm start
	4) 환경 변수 : process.env.development
	
2. 빌드
	1) 명령어 : PS ...> npm run build
	
3. 테스트 코드 실행
 	1) 명령어 : PS...> npm test
 	2) 테스트 파일 인식 조건
 		(1) __test__ 폴더 밑에 있는 모든 자바스크립트 파일
 		(2) 파일 이름이 .test.js로 끝나는 파일
 		(3) 파일 이름이 .spec.js로 끝나는 파일
 	3) 옵션 : watch모드가 필요없는 환경에서 테스트
 		(1) 맥 : CI=true npm test
 		(2) 윈도우 : "CI=ture" && npm test
 	4) 환경 변수 : process.env.test
 	
4. 설정 파일 추출하기
	1) 명령어 : PS...> npm run eject
	2) 환경 변수 : process.env.production
```

* 폴리필

```
실행 시점에 주입하고자 하는 객체나 함수가 현재 환경에 존재하는지 검사해서 존재하지 않는 경우에만 주입하는 것
```

* autoprefixer

```
최신 브라우저는 벤더 접두사 없이도 css의 최신 기능을 사용할 수 있다. 하지만 오래된 버전의 브라우저를 지원하기 위해서는 벤더 접두사를 꼭 붙여줘야 하는데 autoprefixer 패키지를 사용하면 자동으로 벤더 접두사가 붙는다
```

### 4) CSS 작성 방법 결정

* css-module

```
1. css-module : 일반적인 CSS 파일에서 클래스명이 충돌할 수 있다는 단점을 극복할 수 있다.
2 
```

* Sass

```

```

### 5) 단일 페이지 애플리케이션

```
1. SPA, single page application : 최초 요청 시 서버에서 첫 페이지를 처리하고 이후의 라우팅은 클라이언트에서 처리하는 웹 애플리케이션

2. SPA 구현시 필요 기능
	1) 자바스크립트에서 브라우저로 페이지 전환 요청을 보낼 수 있다. 하지만 브라우저는 서버로 요청을 보내지 않아야 한다
	2) 브라우저의 뒤로 가기와 같은 사용자의 페이지 전환요청을 자바스크립트에서 처리할 수 있다. 하지만 브라우저는 서버로 요청을 보내지 않아야 한다
```

* react-router-dom

```
1. react-router-dom을 사용하기 위해서는 전체를 BrowserRouter 컴포넌트로 감싸야 한다

2. '/' 단위로 비교하여 컴포넌트를 렌더링 한다. 따라서 현재 주소가 path 속성 값으로 시작하면 component 속성값이 가리키는 컴포넌트를 렌더링한다
```

## 2. 자바스크립트 최신 문법

### 1) const, let : 변수를 정의하는 새로운 방법

* `var` 가 가진 문제

```
1. 함수 스코프 : 함수 안에서 var 키워드를 사용하지 않고 변수에 값을 할당하면 그 변수는 전역 변수가 된다. 하지만 함수 안에서 var 키워드를 사용하면 해당 변수는 함수 스코프를 가지게 된다. 이런 상황에 대처하기 위해 use stict; 를 사용하기도 한다

2. 호이스팅(hoisting) : var로 정의된 변수는 해당 변수가 속한 스코프의 최상단으로 끌어올려진다. 호이스팅은 다른 프로그래밍 언어에서는 찾아 보기 힘든 성질에 해당해 코드가 직관적이지 않게 보인다.

3. 변수 재정의 : var를 이용하면 한 번 정의된 변수를 재정의할 수 있다. 따라서 코드가 직관적이지 않으며, var가 재할당 가능한 변수로 밖에 만들 수 없게 된다.
```

* const, let

```
1. 블록 스코프 : const와 let은 블록스코프를 갖는다.

2. const, let 호이스팅 : const와 let으로 정의된 변수도 호이스팅 되지만 변수가 정의된 위치와 호이스팅된 위치 사이인 임시적 사각지대(temporal dead zone)에서 변수를 사용하려고 하면 에러가 발생한다

3. 변수 재정의
	1) let : 정의된 변수를 재할당 할 수 있다
	2) const : 변수 재할당이 불가능하다. 다만 const로 정의된 객체의 내부 속성값은 수정 가능하다
  	3) 객체 내부 속성 값을 변경하지 못하도록 하는 방법 
    	(1) immer, immutable.js : 객체의 내부 속성값도 수정 불가능하게 만들고 싶은 경우 사용하는 외부 패키지이다. 해당 패키지를 사용하면 객체를 수정하려고 할 때 기존 객체는 변경하지 않고 새로운 객체를 생성한다
    	(2) 자바스크립트 내장 함수
        	a) 종류
        		(a) Object.preventExtensions
        		(b) Object.seal
        		(c) Object.freeze
        	b) 의미 : 해당 내장 함수를 사용하면 객체의 내부 속성 값을 단지 수정하지 못하게 차단해준다
```

### 2) 객체 및 배열의 사용성 개선

* 객체 및 배열을 간편하게 생성 및 수정하는 방법

```
1. 단축 속성명, shorthand property names
	1) 의미 : 객체 리터럴 코드를 간편하게 작성할 목적으로 만들어진 문법이다
	2) 특징
		(1) 새로 만들려는 객체의 속성값 일부가 이미 변수로 존재하면 간단하게 이름만 적어주면 속성명이 변수 이름과 같아진다
		(2) 속성값이 함수이면 function 키워드 없이 함수명만 적어주면 속성명이 함수명과 같아진다
		
2. 계산된 속성명, computed property names
	1) 의미 : 객체의 속성명을 동적으로 결정하기 위해 나온 문법
```

* 객체와 배열의 속성값을 간편하게 가져오는 방법

```
1. 전개 연산자, spread operator
	1) 의미 : 배열이나 객체의 모든 속성을 풀어놓을 때 사용하는 문법
	2) 특징
		(1) 배열의 경우 전개 연산자를 사용하면 그 순서가 유지된다 
		(2) 중복된 속성명을 사용하는 서로 다른 두 배열이나 객체를 전개연산자를 사용해 합칠 경우 최종 결과는 마지막 속성명의 값이 나타난다
		
2. 배열 비구조화, array destructuring
	1) 의미 : 배열의 여러 속성값을 변수로 쉽게 할당할 수 있는 문법
	2) 특징
		(1) 배열의 속성값이 undefined라면 정의된 기본값이 할당되고 그렇지 않으면 원래의 속성값이 할당된다
		(2) 배열에서 일부 속성값을 무시하고 진행하고 싶은 경우에는 건너뛰는 갯수만큼 쉼표를 입력하면 된다
		
3. 객체 비구조화, object destructuring
	1) 의미 : 객체의 여러 속성값을 변수로 쉽게 할당할 수 있는 문법
	2) 특징
		(1) 배열 비구조화에서 순서는 중요했지만 이와 달리 객체 비구조화에서 순서는 무의미하다
		(2) 배열 비구조화에서 왼쪽 변수의 이름을 임의로 결정할 수 있지만 객체 비구조화에서는 기존 속성명을 그대로 사용해야한다
		(3) 기본값
			a) 객체 비구조화에서 기본값을 정의할 수 있다. 속성값이 undefined인 경우에는 기본값이 들어간다
			b) 기본값 정의시 별칭을 함께 사용할 수 있다
			c) 기본값으로 함수의 반환값을 넣을 수 있다
			
4. 비구조화 심화
	1) 객체와 배열이 중첩되어 있을 때도 비구조화를 사용할 수 있다
	2) 비구조화에서 기본값의 정의는 변수로 한정되지 않는다
```

### 3) 강화된 함수 기능

```
1. 매개변수 추가 기능
	1) 매개변수 기본 값 : ES6부터 함수 매개변수에 기본값을 줄 수 있다
	2) 나머지 매개변수 : 입력된 인수 중에서 정의된 매개변수의 갯수만큼을 제외한 나머지를 배열로 만들어 준다
	3) 명명된 매개변수 : 객체 비구조화를 이용해 구현할 수 있다. 함수 호출 시 매개변수의 이름과 값을 동시에 적을 수 있다
	
2. 화살표 함수
	1) 형태 : 타입 변수 = (매개변수) => {코드;}
	2) 특징
		(1) 화살표 함수를 중괄호로 감싸지 않으면 코드 결과가 반환된다
		(2) 명시적으로 return 키워드를 작성하지 않아도 된다
		(3) 매개변수가 하나인 경우에는 매개변수를 감싸는 소괄호도 생략할 수 있다
		(4) 객체를 반환해야 하는 경우에는 코드를 소괄호로 감싸야 한다
		(5) 코드가 여러 줄인 경우에는 전체를 중괄호로 묶고 반환값에 return 키워드를 사용한다
		(6) 일반 함수와 다르게 this와 arguments가 바인딩되지 않는다
		(7) 화살표 함수 안에서 사용된 this와 arguments는 자신을 감싸고 있는 가장 가까운 일반 함수의 것을 참조한다
		(8) 생성자 함수 내부에서 정의된 화살표 함수의 this는 생성된 객체를 참조한다
```

### 4) 프로미스

```
1. 프로미스
	1) 의미 : 비동기 상태를 값으로 다룰 수 있는 객체이다. 프로미스를 사용하면 비동기 프로그래밍을 할 때 동기 프로그래밍 방식으로 코드를 작성할 수 있다. 콜백 패턴 코드와 다르게 코드가 순차적으로 실행되게 작성할 수 있다
	2) 프로미스 상태 : 프로미스는 대기중 상태일 경우에만 다른 상태로 변화가 가능하며 한번 처리된 경우에는 다른 상태로 변경되지 않는다
		1) 대기중, pending : 결과를 기다리는 중
		2) 처리됨, settled
			(1) 이행됨, fulfilled : 수행이 정상적으로 끝났고 결과값을 가지고 있다
			(2) 거부됨, rejected : 수행이 비정상적으로 끝났다
	3) 생성
		(1) new 키워드 사용
        	a) 선언 : const 변수 = new Promise((resolve, reject)) =>{코드}
        	b) 매개변수
        		(a) resolve : 작업을 수행 한 후 성공했을 때 호출되는 매개변수
        		(b) reject : 작업을 수행 한 후 실패했을 때 호출되는 매개변수
        (2) Promise.reject
        	a) 선언 : const 변수 = Promise.reject();
        	b) 의미 : 거부됨 상태인 프로미스 생성
        (3) Promise.resolve
        	a) 선언 : const 변수 = Promise.resolve();
        	b) 의미 : 입력값이 프로미스 였다면 그 객체가 그대로 반환되고 프로미스가 아니라면 이행된 상태인 프로미스가 반환된다
	4) 사용
		(1) .then
			a) 의미 : 처리됨 상태가 된 프로미스를 처리할 때 사용되는 메서드이다. 프로미스가 처리됨 상태가 되면 then 메서드의 인수로 전달된 함수가 호출된다
			b) 특징
				(a) then 메서드는 항상 프로미스를 반환한다. 따라서 하나의 프로미스로부터 연속적으로 then 메서드를 호출할 수 있다
				(b) 항상 연결된 순서대로 호출된다
		(2) .catch
			a) 의미 : 프로미스 수행 중 발생한 예외를 처리하는 메서드. then메서드의 onReject함수와 같은 역할을 한다
		(3) .finally
			a) 의미 : 프로미스가 이행됨 또는 거부됨 상태일 때 호출되는 메서드. 프로미스 체인의 가장 마지막에 사용된다. .then(onFinally, onFinally) 코드와 유사하지만 이전에 사용된 프로미스를 그대로 반환한다는 점에서 다르다
		(4) Promise.all
			a) 의미 : then 메소드 사용시 체인으로 연결하면 각각의 비동기 처리가 벙렬로 처리되지 않는다는 단점을 극복하고자, 여러 개의 프로매스를 병렬로 처리할 때 사용하는 함수
			b) 특징 :
				(a) Promise.all 함수는 프로미스를 반환한다. 따라서 입력된 모든 프로미스가 처리되지 않으면 프로미스가 거부됨 상태가 된다
		(5) Promise.race
			a) 의미 : 여러 개의 프로미스 중에서 가장 빨리 처리된 프로미스를 반환한느 함수이다. 따라서 입력된 여러 프로미스 중에서 하나라도 처리됨 상태가 되면 함수가 반환하는 프로미스도 처리됨 상태가 된다
	5) 주의점
		(1) return 키워드를 반드시 사용해야한다 : return 키워드를 사용하지 않으면 프로미스 객체의 데이터는 undefined 된다
		(2) 프로미스는 불변 객체이다
		(3) 프로미스를 중첩해서 사용하지 않아야 한다
		(4) 예외처리에 신경써야 한다
```

### 5) async await

```

```

### 6) 템플릿 리터럴

```
1. 템플릿 리터럴 : 더하기 기호와 따옴표를 반복적으로 사용해 문자열을 생성하던 방식에서 벗어나 백틱(``)을 이용해 동적인 문자열을 생성한다
```

### 7) 제너레이터

```
1. 제너레이터 : 함수의 실행을 멈추는 시점을 자발적으로 선택하여 값을 전달하고 다른 함수와 협업 멀티태스킹이 가능한 기능

2. 
```

## 3. 리액트의 주요 개념

### 1) UI 데이터 관리

```
1. UI데이터 : 컴포넌트 내부에서 관리되는 상탯값과 부모 컴포넌트에서 내려주는 속성값으로 구성된다. UI데이터가 변경되면 리액트는 컴포넌트의 렌더 함수를 이용해 화면을 자동으로 갱신해준다

2. 명령혈 프로그래밍과 선언형 프로그래밍
	1) 명령형 프로그래밍, imperative programming : 화면을 어떻게 그리는지 나타내는 프로그래밍 방법. 상당히 구체적으로 그리기 때문에 DOM 환경이 아닌 곳에서는 사용하기 힘들다.
	2) 선언형 프로그래밍, declarative programming : 화면에 무엇을 그리는지 나타내는 프로그래밍 방법. 추상화 단계가 더 높기 때문에 비즈니스 로직에 집중 할 수 있다는 장점이 있다.
	
3. 컴포넌트의 속성값과 상탯값
	1) 컴포넌트 상탯값
		(1) 의미 : 해당 컴포넌트가 관리하는 데이터. 상탯값을 사용하지 않으면 리액트가 UI데이터가 변경되었다는 사실을 파악하지 못한다.
		(2) 특징
			a) 상탯값을 관리할 수 있으므로 상탯값은 불변 객체가 아니다.
			b) 상탯값이 불변 객체가 아니므로 직접 수정이 가능하다
		(3) state 멤버 변수 : 상탯값을 관리하기 위해 리액트가 사용하는 예약어이다. 
		(4) setState메서드
			a) 기능 : 클래스형 컴포넌트에서 상탯값을 변경할 때 호출하는 메서드
			b) 특징
				(a) setState메서드로 입력된 객체는 기존 상탯값과 병합된다
				(b) 리액트는 여러 개의 setState메서드를 batch로 처리한다
                (c) setState의 인수로 함수를 입력할 수 있다
                (d) setState 메서드는 비동기로 처리되지만 호출 순서대로 상탯값이 변경되는 특성을 갖는다.
                (e) setState 메서드의 두 번째 매개변수는 처리가 끝났을 때 호출되는 콜백 함수다
	2) 컴포넌트 속성값 
		(1) 의미 : 부모 컴포넌트로부터 전달받은 데이터
		(2) 특징
			a) 속성값은 불변 객체이다
			b) 자식 컴포넌트에 전달되는 속성값은 상위 컴포넌트에서 관리하기 대문에 수정할 수 없다. 대신 부모 객체에서 직접 수정해야 한다
```

### 2) 리액트 요소와 가상 돔

```
1. 리액트 요소 : 리액트가 UI를 표현하는 수단. 리액트는 전달된 리액트 요소를 이전의 리액트 요소와 비교해서 변경된 부분만 실제 돔에 반영해 돔 변경을 최소화한다.

2. 리액트 요소가 돔 요소로 만들어지는 과정
	1) 과정 구조 : 하나의 화면을 표현하기 위해 여러 개의 리액트 요소가 tree 구조로 구성된다
	2) 과정
    	(1) 렌더 단계, render phase : 실제 돔에 반영할 변경 사항을 파악하는 단계. ReactDOM.render 함수와 setState 메서드에 의해 시작된다.
        (2) 커밋 단계, commit phase : 파악된 변경 사항을 실제 돔에 반영하는 단계
```

### 3) 생명 주기 메서드

```
1. 단계
	1) 초기화 단계
		(1) 의미 : 최초에 컴포넌트 객체가 생성될 때 한 번 수행된다
		(2) 호출 순서
			a) constructor(props)
			b) static getDerivedStateFromProps(props, state)
			c) render()
			d) componentDidMount()
	2) 업데이트 단계
		(1) 의미 : 컴포넌트의 속성갑 또는 상탯값이 변경되면 업데이트 단계가 수행된다. 초기화 단계와 소멸 단계 사이에서 반복해서 수행된다.
		(2) 호출 순서
	3) 소멸 단계
		(1) 호출 순서
            a) static getDerivedStateFromProps()
            b) shouldComponentUpdate()
            c) render()
            d) getSnapshotBeforeUpdate()
            e) componentDidUpdate()
	4) 예외 발생 시
		(1) Static getDerivedStateFromError()
		(2) componentDidCatch()

2. constructor(props) 메서드
	1) 구조 : constructor(props){ super(props) ...}
	2) 특징
		(1) props 매개변수는 컴포넌트의 기본 속성값이 적용된 상태로 호출된다
		(2) constructor 메서드 내부에서 반드시 super 함수를 호출해야 한다. super 함수를 호출해야 React.Component 클래스의 constructor 메서드가 호출된다
		(3) constructor 메서드에서는 상탯값을 직접 할당할 수 있다
		(4) constructor 메서드 내부에서 호출되는 setState 메서드는 무시된다

3. static getDerivedStateFromProps(props, state) 메서드
	1) 구조 : static getDerivedStateFromProps(props, state){...}
	2) 특징
		(1) 속성 값을 이용해 새로운 상탯값을 만든다. 따라서 해당 메서드는 이전 속성값과 이후 속성값 모두 의존적인 상탯값이 필요할 때 사용한다. 
		(2) 정적 메서드이므로 함수 내부에서 this 객체에 접근할 수 없다. 오로지 속성값과 상탯값을 기반으로 새로운 상탯값을 만든다
        (3) 속성값 변경 시 상탯값을 초기화하는 코드는 지양해야 한다

4. render() 메서드
	1) 특징
		(1) 화면에 보여질 반환값의 내용을 결정하는 메서드. 따라서 컴포넌트 작성시 반드시 작성해야 한다
		(2) React.Fragment를 사용하면 내부의 리액트 요소에 key 속성값을 부여하지 않아도 된다.
		(3) ReactDOM.createPortal을 사용하면 컴포넌트의 현재 위치와는 상관없이 특정 돔 요소에 렌더링할 수 있다.
		(4) 렌더 함수 내부에 setState를 호출하면 안된다
		(5) 렌더 함수의 반환값은 속성값과 상탯값만으로 결정되어야 한다
		(6) 부수 효과를 발생시키면 안된다
	2) 반환 할 수 있는 값
		(1) 컴포넌트
		(2) HTML에 정의된 태그
		(3) 문자열과 숫자
		(4) 배열. 단 리액트 요소는 key 속성값을 가지고 있어야 한다 
		(5) null or boolean 값. 단 아무것도 랜더링되지 않는다

5. componentDidMount() 메서드
	1) 구조
	2) 특징
		(1) render() 메서드의 첫 번째 반환값이 실제 돔에 반영된 직후 호출된다
		(2) 해당 메서드를 사용하면 setState 메서드가 마운트 이후에만 동작한다. 따라서 해당 메서드는 API호출을 통해 데이터를 가져올 경우에 적합하다.

6. shouldComponentUpdate() 메서드
	1) 구조 : shouldcomponentUpdate(nextProps, nestState)
	2) 특징
		(1) 렌더링 성능 최적화를 위해 존재한다
		(2) 불 타입을 반환한다. true가 반환되면 render 메서드가 호출되며 false를 반환하면 업데이트 단계가 해당 메서드에서 멈춘다

7. getSnapshotBeforUpdate() 메서드
	1) 구조 : getSnapshotBeforeUpdate(prevProps, prevState) => snapshot
	2) 특징
		(1) 해당 메서드가 반환한 값은 componentDidUpdate 메서드의 세 번째 인자로 들어간다
		
8. componentDidUpdate() 메서드
	1) 구조 : componentDidUpdate(preProps, prevState, snapshot)
	2) 특징
		(1) 초기화 단계에서는 호출되지 않는다

9. componentWillUnmount
	1) 구조
	2) 특징
		(1) 소멸 단계에서 호출되는 유일한 생명 주기 메서드
		(2) componentDidMount 메서드가 호출되면 해당 메서드도 호출되는 것이 보장된다
		
10. getDerivedStateFromError, componentDidCatch 메서드
	1) 구조
		(1) static getDerivedFromError(error)
		(2) componentDidCatch(error, info)
```

### 4) 콘텍스트로 API 데이터 전달

```
1. 콘텍스트 API : 콘텍스트 API를 사용하면 Profile 컴포넌트가 중간에 개입하지 않고도 상위 컴포넌트에서 하위에 있는 모든 컴포넌트로 직접 데이터를 전달할 수 있다.

2. 활용
	1) 여러 콘텍스트 중첩해서 사용하기 : 데이터의 종류별로 콘텍스트를 만들어서 사용하면 데이터 변경시 해당 컴포넌트만 렌더링되므로 렌더링 성능상 이점이 있다.
	2) 생명 주기 메서드에서 콘텍스트 데이터 사용하기 : 
```

### 5) ref 속성값으로 자식 요소 접근

```

```

