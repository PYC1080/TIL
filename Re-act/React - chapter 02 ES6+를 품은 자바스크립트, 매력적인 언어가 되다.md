# Re-act : chapter02 ES6+를 품은 자바스크립트, 매력적인 언어가 되다

> 실전 리액트 프로그래밍 : 리액트 훅부터 Next.js 까지



## 2.1 변수를 정의하는 새로운 방법 : const, let

### 1) var 가 가진 문제

#### (1) var의 첫 번째 문제 : 함수 스코프

* 스코프(scope) : 변수가 사용될 수 있는 영역

#### (2) var의 두 번째 문제 : 호이스팅(hoisting)

* 호이스팅(hoisting) : var로 정의된 변수는 그 변수가 속한 스코프의 최상단으로 끌어 올려지는 것을 호이스팅이라 부른다. 따라서 호이스팅이 발생하면 코드가 직관적이지 않은 문제가 발생한다.

#### (3) var의 기타 문제들 : 변수 재정의

* var를 사용하면 한 번 정의된 변수를 재정의 할 수 있다 : 변수를 정의한다는 것은 이전에 없던 변수를 생성한다는 것이다. 그러나 var를 사용하면 변수를 재정의 할 수 있어 코드가 직관적이지 않게 보이며 버그로 이어질 수 있다.

### 2) var의 문제를 해결 : const, let

#### (1) const, let은 블록 스코프다

#### (2) const, let에서의 호이스팅

* const, let으로 정의된 변수도 호이스팅 된다. 하지만 const 또는 let으로 변수를 정의하기 전에 해당 변수를 사용하려 하면 참조에러가 발생한다.
* `임시적 사각지대(temporal dead zone)` : 변수가 정의된 위치와 호이스팅된 위치 사이에서 변수를 사용하려고 하면 에러가 발생하는 구간.

### (3) const는 변수를 재할당 불가능하게 만든다.

* const로 정의된 변수에 값을 재할당하면 에러가 발생한다. 하지만 const로 정의된 객 내부 속성 값을 수정하고나 새로운 속성 값을 추가하는 것은 가능하다.



## 2.2 객체와 배열의 사용성 개선

### 1) 객체와 배열을 간편하게 생성하고 수정

#### (1) 단축 속성명

* `단축 속성명(shorthand property names)` : 객체 리터럴 코드를 간편하게 작성할 목적으로 만들어진 문법. 이를 통해 간편하게 새로운 객체를 만들 수 있다.

#### (2) 계산된 속성명

* `계산된 속성명(computed property names)` : 객체의 속성명을 동적으로 결정하기 위해 나온 문법

### 2) 객체와 배열의 속성 값을 간편하게 가져오는 기능

#### (1) 전개 연산자

* `전개 연산자(spread operator)` : 배열이나 객체의 모든 속성을 풀어놓을 때 사용하는 문법

#### (2) 배열 비구조화

* `배열 비구조화(array destructuring)` : 배열의 여러 속성 값을 변수로 쉽게 할당할 수 있는 문법.

```
1. 형태 : [ ...]
2. 순서가 중요하다
3. 변수의 이름을 임의로 결정할 수 있다.
4. 배열 비구조화 시 기본값 정의
	1) 속성값이 undefined인 경우 : 기본값이 들어간다
	2) 속성값이 undefined이지 않은 경우 : 기본값이 들어가지 않는다
```

#### (3) 객체 비구조화

* `객체 비구조화(object destructuring)` : 객체의 여러 속성값을 변수로 쉽게 할당 할 수 있는 문법.

```
1. 형태 : { ...}
2. 순서는 중요하지 않다
3. 변수의 이름이 중요하므로 기존 속성명을 그대로 사용해야한다
4. 객체 비구조화 시 기본값 정의
	1) 속성값이 undefined인 경우 : 기본값이 들어간다
	2) 속성값이 null인 경우 : 기본값이 들어가지 않는다 
5. 기본값으로 함수의 반환값을 넣을 수 있다.
```

#### (4) 비구조화 심화 학습

* 비구조화는 객체와 배열이 중첩되어 있을 때도 사용할 수 있다.



## 2.3 강화된 함수의 기능

### 1) 매개변수에 추가된 기능

#### (1) 매개변수 기본값

* 매개변수 기본값 : ES6부터 함수 매개변수에 기본값을 줄 수 있다

#### (2) 나머지 매개변수

* `나머지 매개변수(rest parameter)` : 입력된 인수 중에서 정의된 매개변수 갯수만큼을 제외한 나머지를 배열로 만들어 준다

#### (3) 망명된 매개변수

* `망명된 매개변수(named parameter)` 사용의 효과

```
1. 함수 호출시 매개변수의 이름과 값을 동시에 적을 수 있어 가독성이 올라간다
2. 있어도 되고 없어도 되는 매개변수인 선택적 매개변수의 활용도가 올라간다
```

### 2) 함수를 정의하는 새로운 방법 : 화살표 함수

* `화살표 함수(arrow function)`

```
1. 매개변수가 하나라면 매개변수를 감사는 소괄호도 생략할 수 있다.
2. 객체를 반환해야 한다면 소괄호로 감싸야 한다
```

#### (1) 화살표 함수의 코드가 여러 줄인 경우

* 화살표 함수에 여러 줄의 코드가 필요한 경우 : 전체를 중괄호로 묶고 반환값에는 `return` 키워드를 사용한다

#### (2) this 와 arguments가 바인딩되지 않는 화살표 함수

* 화살표 함수가 일반 함수와 다른 점은 this와 arguments가 바인딩 되지 않는다는 점이다. 따라서 화살표 함수에서 arguments가 필요하면 나머지 매개변수를 이용한다

#### (3) 일반 함수에서 this 바인딩 때문에 버그가 발생하는 경우

* 일반 함수에서 this는 호출 시점에 사용된 객체로 바인딩 도니다. 따라서 객체에 정의된 일반 함수를 다른 변수에 할당해서 호출하면 버그가 발생할 수 있다.

#### (4) 생성자 함수 내부에서 정의된 화살표 함수의 this

* 생성자 함수 내부에서 정의된 화살표 함수의 this는 생성된 객체를 참조한다

#### (5) setInterval 함수 사용 시 this 바인딩 문제

* 클로저 개념 이해하기

```
클로저는 함수가 생성되는 시점에 접근 가능했던 변수들을 생성 이후에도 계속해서 접근할 수 있게 해주는 기능이다.
```



## 2.4 향상된 비동기 프로그래밍 1: 프로미스



## 2.5 향상된 비동기 프로그래밍 2: async aswait



## 2.6 템플릿 리터럴로 동적인 문자열 생성하기



## 2.7 실행을 멈출 수 있는 제너레이터

