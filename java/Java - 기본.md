# Java - 기본

## 1. 자바 도입

### 1) 프로그래밍 언어와 자바

```
1. 소스 파일, source file : 프로그래밍 언어로 작성한 파일
2. 컴파일, compile : 소스 파일을 0과 1로 이루어진 기계어 파일로 변역해 컴퓨터가 이해 할 수 있도록 바꿔주는 작업
3. 자바의 특징
	1) 자바로 작성된 프로그램은 모든 운영체제에서 실행 가능하다
	2) 객체를 만들고 객체들을 서로 연결해서 더 큰 프로그램을 완성하는 객체 지향 프로그래밍 기법(Object-Oriented Programming)을 사용
    3) 메모리를 자동으로 관리
    4) 오픈 소스 라이브러리가 풍부
4. Java Development kit : Java SE 주버전.개선버전.업데이트버전(LTS)
	1) 주 버전 : 자바 언어에 많은 변화가 있을 경우 증가된다
	2) 개선 버전 : 주 버전에서 일부 사항이 개선될 때 증가
	3) 업데이트 버전 : 버그 수정시 증가
	4) LTS : Long term support 장기 지원 서비스를 받을 수 있는 버전
```

### 2) 개발 환경 구축

```
1. IDE, Integrated Development Environment : 프로젝트 생성, 자동 코드 완성, 디버깅 등과 같이 개발에 필요한 여러 가지 기능을 통합적으로 제공해주는 툴
2. 워크스페이스 : metadata와 project_foler가 저장되는 폴더
3. 뷰 : 내부 실행 창
4. 퍼스펙티브 : 프로젝트를 개발할 때 유용하게 사용할 수 있는 뷰들을 미리 묶어 이름 붙여 놓은 것
```

### 3) 자바 프로그램 개발 과정

```
1. 자바 컴파일 과정 : 자바 소스 파일(.java) -> 바이트 코드 파일(.class) -> 실행
	1) 컴파일 : javac 명령어를 실행해 자바 소스 파일을 바이트 코드 파일로 변환한다
	2) JVM, Java Virtual Machine : java 명령어를 실행해 바이트 코드 파일을 기계어로 변환한다. 변환한 기계어를 JVM이 실행시킨다
2. 프로그램 소스 분석
	1) 클래스 선언
    	(1) 구조 : 클래스 선언부{클래스 블록}
    	(2) 특징 : 클래스 이름은 소스 파일명과 동일해야 하며, 대소문자도 일치해야 한다
	2) 메소드 선언
		(1) 구조 : 메소드 선언부{메소드 블록}
		(2) 특징 : 자바 명령어로 바이트 코드 파일을 실행하면 제일 먼저 main()메서드(진입점, entry point)를 찾아 블록 내부를 실행한다
3. 주석
	1) 주석 : 프로그램 실행과는 상관없이 코드에 설명을 붙인 것
	2) 주석의 종류
		(1) 라인 주석(//...) : //부터 라인 끝까지 주석으로 처리한다
		(2) 범위 주석(/*...*/) : /*와 */ 사이에 있는 내용은 모두 주석으로 처리한다
		(3) 도큐먼트 주석(/**...*/) : /**와 */ 사이에 있는 내용은 모두 주석으로 처리한다
	3) 특징
		(1) 문자열 내부에는 주석을 붙일 수 없다
		(2) 도큐먼트 주석은 javadoc 명령어로 api 도큐먼트를 생성하는 데 사용한다
4. 실행문과 세미콜론
	1) 실행문 : 변수 선언, 값 저장, 메소드 호출에 해당하는 코드
	2) 세미 콜론(;) : 실행문 끝에 세미콜론을 붙여 실행문이 끝났음을 표시해준다
```

## 2. 변수와 타입

### 1) 변수

```
1. 변수, variable : 값을 저장할 수 있는 메모리의 특정 번지에 붙이는 이름
2. 변수 선언
	1) 의미 : 변수에 어떤 타입의 데이터를 저장할 것인지 그리고 변수의 이름이 무엇인지 결정하는 것
	2) 용법 : 타입 변수이름;
	3) 변수이름 특징
		(1) 첫 번째 글자는 문자이거나 '$','_'으로 시작해야 한다
		(2) 숫자로 시작할 수 없다
		(3) 영어의 대소문자를 구분한다
		(4) 첫 문자는 영어 소문자로 시작하되 다른 단어가 붙을 경우 첫 문자를 대문자로 한다
		(5) 문자의 길이는 제한이 없다
		(6) 자바 예약어는 사용할 수 없다
3. 예약어
	1) 의미 : 자바에서 의미를 갖고 사용되고 있는 단어
	2) 종류
		(1) 기본 타입 : boolean, byte, char, short, int, long, float, double
		(2) 접근 제한자 : private, protected, public
		(3) 클래스와 관련된 것 : class, abstract, interface, extends, implements, enum
		(4) 객체와 관련된 것 : new, instanceof, this, super, null
		(5) 메소드와 관련된 것 : void, return
		(6) 제어문과 관련된 것 : if, else, switch, case, default, for, do, while, break, continue
		(7) 논리값 : true, false
		(8) 예외 처리와 관련된 것 : try, catch, finally, throw, throws
		(9) 기타 : package, import, synchronized, final, static
4. 값 저장
	1) 용법 : A = B
	2) 의미 : B 값을 A 변수에 저장한다
	3) 변수 초기화 : 자바에서는 변수에 값이 저장되지 않으면 변수가 생성되지 않는다. 변수에 최초로 값이 저장될 때 변수가 생성되는 것을 변수 초기화라 한다
5. 로컬 변수 : 메소드 블록 내에서 선언된 변수
```

### 2) 기본 타입

* 기본 타입

```
1. 기본 타입
	1) 의미 : 자바가 제공하는 값을 저장할 수 있는 타입
	2) 종류
		(1) 정수 : byte, char, short, int, long
		(2) 실수 : float, double
		(3) 논리 : boolean
2. 정수 타입
	1) 종류별 크기
		(1) byte : 1byte(8bit)
		(2) short : 2byte(16bit)
		(3) char : 2byte(16bit)
		(4) int : 4byte(32bit)
		(5) long : 8byte(64bit)
	2) 정수 리터럴
		(1) 의미 : 소스 코드에서 프로그래머에 의해 직접 입력된 값. 기본값으로 int타입으로 간주한다.
		(2) 자바가 정수로 인식하는 리터럴 값의 종류
			a) 2진수 : 0b... or 0B... , 0과 1 숫자로 구성
			b) 8진수 : 0... , 0~7사이의 숫자로 구성
			c) 10진수 : 소수점이 없는 0~9 사이의 숫자로 구성
			d) 16진수 : 0x... or 0X... , 0~9 사이의 숫자와 ABCDE 혹은 abcde 문자로 구성
		(3) 정수 리터럴 타입값을 long 타입으로 변경하는 방법 : 정수 리터럴 뒤에 'l'이나 'L'을 붙이면 된다
	3) 문자 리터럴
		(1) 의미 : 하나의 문자를 작은 따옴표('')로 감싼 것을 문자 리터럴이라고 한다. 문자 리터럴은 유니코드로 변환되어 저장된다
		(2) 선언 : char 변수명 = ''
3. 실수 타입
	1) 종류별 크기
		(1) float : 4byte(32bit)
		(2) dobule : 8byte(64bit)
	2) 실수 리터럴
		1) 특징
			(1) 소수점이 있는 숫자 리터럴은 10진수 실수로 인식한다
			(2) 'e'or 'E'가 포함되어 있는 숫자 리터럴은 지수와 기수로 표현된 소수점이 있ㄴ느 10진수 실수로 인식한다
			(3) 기본적으로 double 타입으로 간주한다
		2) 실수 리터럴 타입값을 float으로 변경하는 방법 : 실수 리터럴 뒤에 'f'이나 'F'을 붙인다
4. 논리 타입
	1) 의미 : true와 false를 사용해 참과 거짓을 의미하는 논리 리터럴 값
	2) 종류 : boolean		
```

* string 타입

```
1. 문자열 : 자바에서 큰 따옴표("")로 감싼 문자들, ""로 감싼 문자 또는 여러개의 문자들은 유니코드로 변환되지 않는다
2. string 타입 : 기본 타입이 아닌 클래스 타입에 속한다
3. 이스케이프 문자
	1) 의미 : 문자열 내부에 \를 사용해 특정 문자를 포함시킬 때 사용한다
	2) 종류
		(1) \t : 탭만큼 띄움
		(2) \n : 줄바꿈(라인 피드)
		(3) \r : 캐리지리턴
		(4) \" : "출력
		(5) \' : '출력
		(6) \\ : \출력
		(7) \u16 : 16진수 유코드에 해당하는 문자 출력
```

### 3) 타입 변환

```
1. 자동 타입 변환, promotion
	1) 의미 : 값의 허용 범위가 작은 타입이 허용 범위가 큰 타입으로 저장될 때 자동으로 타입이 변환된다
	2) 형태 : 큰 허용 범위 타입 = 작은 허용 범위 타입
	3) 특징
		(1) char 타입을 자동 타입 변환하면 유니코드 값이 저장된다
2. 강제 타입 변환, casting
	1) 의미 : 큰 허용 범위 타입을 작은 허용 범위 타입으로 강제로 나눠서 저장
	2) 형태 : 작은 허용 범위 타입 = (작은 허용 범위 타입) 큰 허용 범위 타입
	3) 특징
		(1) 실수 타입을 정수 타입으로 변환한 경우 소수점 이하 부분은 버려지고 정수 부분만 저장된다
3. 정수 연산에서의 자동 타입 변환 : 정수 타입 변수가 산술 연산식에서 피 연산자로 사용되는 경우, 피 연산자로 사용되는 정수 타입 변수가 byte, short 타입이면 자동으로 int 타입으로 변환되어 연산을 수행한다
4. 실수 연산에서의 자동 타입 변환 : 산술 연산식에서 피연산자가 모두 실수 타입 변수를 사용한 경우, 피 연산자 중 하나가 double 타입이면 다른 피 연산자도 double 타입으로 자동 타입 변환되어 연산을 수행한다
5. + 연산에서 문자열 자동 타입 변환
	1) +연산자의 기능
		(1) 피연산자가 모두 숫자인 경우 : 덧셈 연산
		(2) 피연산자 중 하나 이상이 문자열인 경우 : 문자열 결합 연산
6. 문자열과 기본 타입의 강제 타입 변환
	1) 문자열-> 기본타입 : 기본타입.parse기본타입(str값);
	2) 기본타입-> 문자열 : String.valueOf(기본타입값)
```

### 4) 변수와 시스템 입출력

```
1. 변수값 출력
	1) 형태 : System.out.메소드
	2) 의미
		(1) System : 시스템이 가지고 있는
		(2) out : 출력장치로
		(3) 메소드 : 괄호 안의 내용을 출력하고 메소드 기능을 수행하라
	3) 메소드 종류
		(1) print() : 괄호 안의 내용을 출력만 한다
		(2) println() : 괄호 안의 내용을 출력하고 행을 바꾼다
		(3) printf("형식문자열",값1,값2...) : 괄호 안의 첫 번째 문자열 형식대로 내용을 출력하라 
	4) 형식문자열
		(1) 형태 : %[argument_index$][flags][width][.prrecision]conversion
		(2) 의미 :  %와 conversion은 필수로 작성하며 []은 생략이 가능하다
			a) [argument_index$] : 형식 문자열에 포함될 값이 2개 이상인 경우 나타내는 값의 순번
			b) [flags]
            	(a) 의미 : 빈 자리를 채우는 방법
            	(b) 종류
            		ㄱ) '-' : 생략시 왼쪽이 공백으로 채워지고, '-' 표현시 오른쪽이 공백으로 채워진다
            		ㄴ) '0' : 공백대신에 0으로 채운다
			c) [width] : 전체 자릿수
            d) [.precision] : 소수점 자릿수
            e) conversion
            	(a) 의미 : 변환할 문자
            	(b) 종류
            		ㄱ) d : 정수
            		ㄴ) f : 실수
            		ㅇ) s : 문자열
            		ㄹ) 특수문자
            			(ㄱ) \t : 탭
            			(ㄴ) \n : 줄바꿈
            			(ㄷ) %% : %
2. 키보드 입력
	1) 형태 : System.in.read()
	2) 의미
		(1) System : 시스템이 가지고 있는
		(2) in : 입력장치에서
		(3) read() : 입력된 키코드를 읽는다
	3) 키코드
		(1) 의미 : 키보드에서 키 하나만을 입력하면 프로그램은 숫자로 된 키코드 값을 읽는다
        (2) 종류
        	a) 숫자 : 0~9 (48~57)
        	b) 알파벳: A~Z (65~90) , a~z(97~122)
        	c) 기능키
        		(a) BACK SPACE : 8
        		(b) TAB : 9
        		(c) ENTER
        			A) CR : 13
        			B) LF : 10
        		(d) SHIFT : 16
        		(e) CTRL : 17
        		(f) ALT : 18
        		(g) ESC :27
        		(h) SPACE : 32
        		(i) PAGEUP :33
        		(g) PAGEDOWN : 34
        	d) 방향키
        		(a) 좌 : 37
        		(b) 상 : 38
        		(c) 우 : 39
        		(d) 하 : 40
```

## 3. 연산자

### 1) 연산자와 연산식

```
1. 용어 정리
	1) 연산, operation : 프로그램에서 데이터를 처리하여 결과를 산출하는 것
	2) 연산자, operator : 연산에 사용되는 표시나 기호
	3) 피연산자, operand : 연산자와 함께 연산되는 데이터
	4) 연산식, expression : 연산자와 피연산자를 이용해 연산의 과정을 기술한 것
2. 특징
	1) 연산식은 반드시 하나의 값만을 산출한다. 따라서 하나의 값이 올 수 있는 곳이면 어디든지 값 대신에 연산식을 사용할 수 있다
	2) 우선순위가 같은 연산자들 대부분은 왼쪽에서 오른쪽 방향으로 연산을 수행한다. 그러나 단항 연산자, 부호 연산자, 대입 연산자는 오른쪽에서 왼쪽으로 연산을 수행한다
	3) 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다
	4) 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다
```

### 2) 연산자의 종류

```
1. 단항 연산자
	1) 의미 : 피연산자가 하나뿐인 연산자
	2) 종류  
		(1) 부호 연산자
			a) 의미 : 양수 및 음수를 표시하는 +,-를 말한다. boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용한다
			b) 종류
				(a) + : 피연산자의 부호 유지
				(b) - : 피연산자의 부호 변경
			c) 특징
				(a) 부호 연산자의 결과는 int 타입이다
		(2) 증감 연산자
			a) 의미 : 변수의 값을 1만큼 증가시키거나(++) 감소시키는 연산자(--). booleand 타입을 제외한 모든 기본 타입의 피연산자에 사용할 수 있다
			b) 종류
				(a) ++피연산자 : 다른연산을 수행하기 전에 피연산자의 값을 1 증가시킨다
				(b) --피연산자 : 다른연산을 수행하기 전에 피연산자의 값을 1 감소시킨다
				(c) 피연산자++ : 다른 연산을 수행한 후 피연산자의 값을 1 증가시킨다
				(d) 피연산자-- : 다른 연산을 수행한 후 피연산자의 값을 1 감소시킨다
		(3) 논리부정 연산자
			a) 의미 : !을 사용하여 true를 false로, false를 true로 변경한다. boolean 타입에만 사용할 수 있다
2. 이항 연산자
	1) 의미 : 피연산자가 2개인 연산자
	2) 종류
		(1) 산술 연산자
			a) 의미 : 사칙연산 및 나머지를 구하는 연산자
			b) 종류
				(a) + : 덧셈
				(b) - : 뺄셈
				(c) / : 나눗셈
				(d) * : 곱셈
				(e) % : 나머지
			c) 특징
				(a) 피연산자들의 타입이 동일하지 않을 경우 피연산자들의 타입을 일치시킨 후 연산을 수행한다
		(2) 문자열 결합 연산자
			a) 의미 : +를 사용해 문자열을 서로 결합한다
		(3) 비교 연산자
			a) 의미 : 피연산자의 대소, 동등 등을 비교해서 true/false를 산출한다
			b) 종류
				(a) == : 두 연산자의 값이 같은지를 검사한다
				(b) != : 두 연산자의 값이 다른지를 검사한다
				(c) > : 좌변의 피연산자 값이 우변의 피연산자 값보다 크다
				(d) >= : 좌변의 피연산자 값이 우변의 피연산자 값보다 크거나 같다
				(e) < : 좌변의 피연산자 값이 우변의 피연산자 값보다 작다
				(f) <= : 좌변의 피연산자 값이 우변의 피연산자 값보다 작거나 같다
		(4) 논리 연산자
			a) 의미 : 논리곱, 논리합, 배타적 논리합, 논리부정 연산을 수행한다. boolean 타입만 사용할 수 있다
            b) 종류
            	(a) 논리곱(&&or&)
            		true && true : true
            		true && false : false
            		false && true : false
            		false && false : false
            	(b) 논리합(||or|)
                	true || true : true 
            		true || false : true
            		false || true : true
            		false || false : false
            	(c) 배타적 논리합(^)
                	true ^ true : false 
            		true ^ false : true
            		false ^ true : true
            		false ^ false : false
            	(d) 논리 부정
            		! true : false
            		! false : true
       (5) 대입 연산자
       		a) 종류
       			(a) = : 오른족의 피연산자의 값을 왼쪽 변수에 저장한다
       			(b) += : 오른쪽 피연산자 값을 왼쪽 변수에 더한다
       			(c) -= : 오른쪽 피연산자의 값을 왼쪽 변수에 뺀다
       			(d) *= : 오른쪽 피연산자의 값을 왼쪽 변수에 곱한다
       			(e) /= : 오른쪽 피연산자의 값을 왼쪽 변수에 나눈다
       			(f) &= : 오른쪽 피연산자와 왼쪽 변수의 논리곱을 구한 값을 변수에 넣는다
           		(g) |= : 오른족 피연산자와 왼쪽 변수의 논리합을 구한 값을 변수에 넣는다
                (h) ^= : 오른족 피연산자와 왼쪽 변수의 배타적 논리합을 구한 값을 변수에 넣는다
3. 삼항 연산자
	1) 의미 : 3개의 연산자를 필요로 하는 연산자이다. 조건식의 결과에 따라 수행하는 연산자의 종류가 달라진다
	2) 형태 : 조건식 ? 조건식이 참인 경우 실행하는 값 또는 연산식 : 조건식이 거짓인 경우 실행하는 값 또는 연산식
```

## 4. 조건문과 반복문

### 1) 조건문

```
1. if문

if(조건식){
	조건식이 true인 경우 실행할 코드
}


2. if-else문

if(조건식){

} 조건식이 true인 경우 실행할 코드
else {
조건식이 false인 경우 실행할 코드
}

3. if-else if-else문

if(조건식1){
	조건식1이 true인 경우 실행할 코드
} else if(조건식2){
	조건식1이 false이면서 조건식2이 true인 경우 실행할 코드
} else{
	조건식이 모두 false인 경우 실행할 코드
}

4. switch문

switch(변수){
	case 값1: 
		변수의 값이 값1인 경우 실행할 코드
		break;
	case 값2: 
		변수의 값이 값2인 경우 실행할 코드
		break;
	...
	default:
		변수의 값이 case에 모두 해당하지 않는 경우 실행할 코드
}
```

### 3) 반복문

```
1. for문

for(초기화식; 조건식; 증감식){
	조건식이 true인 경우 반복해서 실행할 코드
}

2. 향상된 for 문 : 배열에서 가져올 값이 있는 경우 타입 변수에 저장되며 실행문이 실행된다. 배열의 항목 수만큼 반복 된다

for(타입 변수 : 배열){
	실행 코드
}

3. while문

while(조건식){
	조건식이 true인 경우 반복해서 실행할 코드
}

4. do-while문 : 먼저 실행문 내부를 실행하고 실행결과에 따라 반복 실행을 계속할지 결정한다
do{
	조건식이 true인 경우 반복해서 실행할 코드
}while(조건문)

5. break
	1) 반복문이 중첩되어 있을 경우 break문은 가장 가까운 반복문만 종료시킨다
	2) 중첩된 반복문에서 바깥쪽 반복문까지 종료시키려면 바깥쪽 반복문에 이름을 붙이고 break 이름;을 사용하면된다

6. continue
	1) 반복문을 종료하지 않고 다시 반복문의 처음으로 돌아가 계속 반복을 수행한다
```

## 5. 참조 타입

### 1) 참조 타입과 참조 변수

```
1. 참조 타입 : 객체의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스를 말한다
2. 메모리 사용 영역, Runtime Data Area
	1) 메소드 영역, method area : JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역, 클래스별로 정적 필드와 상수, 메소드 코드, 생성자 코드 등을 분류해서 저장한다
	2) 힙 영역, heep area : 객체와 배열이 생성되는 영역
	3) JVM 스택 영역 : 메소드를 호출할 때마다 프레임을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거하는 동작(pop)을 수행한다
3. 참조 변수의 ==, != 연산
	1) 의미 : 참조 타입 변수들이 동일한 객체를 참조하는지 다른 객체를 참조하는지 알아볼 대 사용된다
4. Null과 NullPointerException
	1) Null : 참조 타입 변수가 힙 영역의 객체를 참조하지 않는다는 뜻으로 갖는 값
	2) NullPoitnerException : 참조 변수가 Null 값을 가지고 있을 경우에는 참조 객체가 없으므로 변수를 통해 객체를 사용할 수 없어 NullPointerException가 발생한다
5. String 타입
	1) 선언 : String 변수 = "문자열";
	2) 특징
		(1) 자바는 문자열 리터럴이 동일하다면 String 객체를 공유하게 되어 있다
		(2) 객체 생성 연산자(new)를 사용하면 새로운 객체가 생성되므로 동일한 문자열을 가리키는 것으로 보일지라도 실제로는 서로 다른 String 객체를 참조하게 된다
		(3) .equals() 메소드를 사용하게 되면 String 객체의 문자열만 비교해 같은지를 검사한다
```

### 2) 배열

```
1. 배열
	1) 의미 : 같은 데이터를 연속된 공간에 나열하고 각 데이터에 인덱스를 부여해놓은 자료구조
	2) 특징
		(1) 같은 타입의 데이터만 저장할 수 있다
		(2) 한 번 생성된 배열은 길이를 늘리거나 줄일 수 없다
2. 배열 선언
	1) 타입[] 변수;
	2) 타입 변수[];
3. 배열 생성
	1) 값 목록으로 배열 생성
		(1) 생성 : 타입[] 변수 = {값1, 값2,...};
		(2) 특징
			a) 배열 변수를 선언한 이후에는 다른 실행문에서 중괄호를 사용한 배열 생성이 허용되지 않는다
			b) a)와 달리 new 연산자를 사용해 값 목록을 지정해주는 것은 가능하다
	2) new 연산자로 배열 생성
		(1) 생성 : 타입[] 변수 = new 타입[길이];
		(2) 특징
			a) 이미 배열 변수가 선언된 경우에도 new 연산자로 배열을 생성할 수 있다
			b) new 연산자로 배열을 처음 생성하면 배열은 자동적으로 기본값으로 초기화 된다
				(a) byte[] 초기화 값 : 0
				(b) char[] 초기화 값 : '\u0000'
				(c) short[] 초기화 값 : 0
				(d) int[] 초기화 값 : 0
				(e) long[] 초기화 값 : 0L
				(f) float[] 초기화 값 : 0.0F
				(g) double[] 초기화 값 : 0.0
				(h) boolean[] 초기화 값 : false
				(i) 클래스[] 초기화 값 : null
				(j) 인터페이스[] 초기화 값 : null
4. 배열 길이
	1) 배열의 길이 : 배열에 저장할 수 있는 전체 항목의 갯수
	2) 배열의 길이 확인하는 방법 : .length
5. main()메소드의 String[] args : main() 메소드는 String[] args 매개변수를 통해 명령 라인에서 입력된 배열의 길이와 배열의 항목 값을 알 수 있게 된다
6. 객체 참조 배열
	1) 의미 : 참조 타입(클래스, 인터페이스) 배열은 각 항목에 객체의 번지를 가지고 있다
7. 배열 복사
	1) System.arrarycopy(원본배열, 원본배열 시작 인덱스 번호, 복사할 배열, 복사할 배열 붙여넣을 인덱스 번호, 복사할 배열의 길이)
```

### 3) 열거 타입

```
1. 열거 타입 : 한정된 값인 열거 상수 중에서 하나의 상수를 저장하는 타입
2. 열거 타입 선언
	1) 열거 타입의 이름을 정하고 해당 이름으로 소스 파일(.java)을 생성해야 한다
	2) 관례 : 첫글자는 대문자로 하고 나머지는 소문자로 한다
	3) 관례 : 여러 단어로 구성된 이름이라면 각 단어의 첫글자는 대문자로 한다
	4) public enum 열거타입이름{열거상수}
		(1) 반드시 소문자로 작성해야한다
		(2) 열거타입이름은 소스파일 이름과 대소문자가 모두 일치해야한다
		(3) 관례 : 열거 상수는 모두 대문자로 작성한다
		(4) 관례 : 열거 상수가 여러 단어로 구성될 경우에는 단어 사이를 '_'로 연결한다
3. 열거 타입 변수
	1) 선언 : 열거 타입 변수 = 열거타입.열거상수;
```

## 6. 클래스

### 1) 객체 지향 프로그래밍

```
1. 기본 용어
	1) 객체, object : 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성으 가지고 있으면서 식별 가능한 것
	2) 필드, field : 객체의 속성
	3) 메소드, method : 객체의 동작
2. 객체 간의 관계
	1) 집합 관계 : 객체는 하나의 부품이고 하나는 완성품에 해당한다
	2) 사용 관계 : 객체 간의 상호작용을 말한다. 객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다
	3) 상속 관계 : 상위(부모) 객체를 기반으로 하여 하위(자식) 객체를 구성하는 관계
3. 객체와 클래스
	1) 클래스 : 객체를 생성하기 위한 필드와 메소드가 정의되어있다
	2) 인스턴스 : 클래스로부터 만들어진 객체
4. 클래스 선언
	1) 클래스 선언 식별자 작성 규칙
		(1) 하나 이상의 문자로 이루어져야 한다
		(2) 첫 글자에는 숫자가 올 수 없다
		(3) '_'와 '$'를 제외한 특수 문자는 사용할 수 없다
		(4) 자바 키워드는 사용할 수 없다
		(5) 관례 : 한글로 클래스 이름을 만드는 경우는 없다
        (6) 관례 : 서로 다른 단어가 혼합된 이름을 사용하면 각 단어의 첫글자는 대문자로 작성한다
    2) 클래스 선언 : 접근제한자 class 클래스이름{필드 생성자 메소드}
    	(1) 접근제한자
    		a) 의미 : 파일 이름과 동일한 이름의 클래스 선언에만 붙일 수 있다
    		b) 종류
    			(a) public
    	(2) 필드 
    		a) 의미 : 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다
    		b) 형태 : 타입 필드이름;
    	(3) 생성자
    		a) 의미 : 필드를 초기화 하거나 메소드를 호출해서 객체를 사용할 준비를 한다. 클래스 이름으로 되어 있고 리턴 타입이 없다
    		b) 형태 : 클래스이름(){}
    	(4) 메소드
    		a) 메소드 : 객체 간의 데이터를 전달하는 수단
    		b) 형태 : void 메소드이름(){}
5. 객체 생성과 클래스 변수
	1) 객체 생성 : 클래스 변수 = new 클래스(); , new 연산자 + 생성자
```

### 2) 필드

```
1. 필드, field : 객체의 고유 데이터, 부품, 현재 상테 데이터를 저장하는 곳
2. 필드 선언
	1) 형태 : 타입 필드이름 = 초기값;
	2) 타입 : 기본 타입과 참조 타입이 모두 올수 있다
	3) 초기값 : 필드 선언시 주어지며 생략될 수 있다
```

### 3) 생성자

```
1. 생성자, constructor : new 연산자를 이용해 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다
2. 객체 초기화 : 필드를 초기화 하거나 메소드를 호출해서 객체를 사용할 준비를 하는 것. 생성자가 성공적으로 실행되면 힙(heap) 영역에 객체가 생성되고 객체의 번지가 리턴된다
3. 기본 생성자
	1) 형태 : 접근제한자 클래스(){}
	2) 접근제한자 : 클래스가 public으로 선언되면 기본 생성자의 접근제한자도 public이 붙지만 클래스가 public 없이 class로만 선언되면 기본 생성자에도 public 이 붙지 않는다
4. 생성자 선언 : 클래스(매개변수선언, ...){객체 초기화 코드}
5. 필드 초기화 : 클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다. 다른 값으로 초기화 하고 싶은 경우에는 필드 선언시 초기값을 주거나 생성자에서 초기값을 주면 된다
6. 생성자 오버로딩 : 매개 변수를 달리하는 생성자를 여러 개 선언하는 것
7. 다른 생성자 호출 : this()
```

### 4) 메소드

```
1. 메소드 선언 : 리턴타입 메소드이름([매개변수선언,...]){실행코드}
	1) 리턴타입 : 메소드를 실행한 후의 결과값의 타입
	2) 메소드이름 : 자바식별자 규칙에 맞게 작성
	2) 매개변수선언 : 메소드 실행시 필요한 데이터를 받기 위한 변수. 매개 변수의 갯수를 모를 경우에는 매개 변수를 배열 타입으로 선언하면 된다
2. 리턴문
	1) 리턴값이 있는 메소드 : 메소드 선언에 리턴 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야 한다
	2) 리턴값이 없는 메소드(void) : void로 선언된 메소드에서 return문 사용시 리턴값이 지정되는 것이 아니라 메소드 실행을 강제 종료시키는 역할을 한다
3. 메소드 호출
	1) 클래스 내부의 다른 메소드에서 호출한 경우 : 단순히 메소드 이름으로 호출이 가능하다
	2) 클래스 외부에서 호출할 경우 : 클래스로부터 객체를 생성한 뒤 참조 변수를 이용해 메소드를 호출한다
4. 메소드 오버로딩
	1) 의미 : 클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것
	2) 조건 : 리턴타입 메소드이름 (타입 변수,...){}
		(1) 리턴타입 : 상관 없음
		(2) 메소드이름 : 동일
		(3) 타입변수 : 타입, 갯수, 순서가 다르다
```

### 5) 인스턴스 멤버와 정적 멤버

```
1. 인스턴스 멤버와 this
	1) 인스턴스 멤버 : 객체마다 가지고 있는 멤버로서, 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말한다
	2) this : 객체 내부에서 인스턴스 멤버에 접근하기 위해 사용한다
2. 정적 멤버와 static
	1) 정적 멤버 : 클래스에 고정된 멤버로서, 클래스에 고정시키고 객체들이 공유하는 멤버이므로 객체를 생성하지 않고도 사용할 수 있는 필드와 메소드를 말한다
	2) 정적 메소드 선언 시 주의점
		(1) 내부에 인스턴스 멤버를 곧바로 사용할 수 없다. 만약 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 한다
		(2) this 키워드도 사용이 불가능하다
3. 싱글톤, singleton
	1) 의미 : 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우, 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막는 객체를 싱글톤이라고 한다
	2) 방법 : 생성자를 외부에서 호출할 수 없도록 생성자 앞에 private 접근 제한자를 붙여준다
4. final 필드와 상수
	1) final 필드
		(1) 의미 :초깃값이 저장되면 초깃값이 최종적인 값이 되어 프로그램 실행 도중 수정할 수 없게된다. 초기화되지 않은 final 필드를 그래도 남겨두면 컴파일 에러가 발생한다
		(2) 선언 : final 타입 필드=초깃값;
		(3) 초깃값을 주는 방법
			a) 필드 선언시 주는 방법
			b) 생성자에서 주는 방법
	2) 상수, static final
		(1) 의미 : 객체마다 존재하지 않고 클래스에만 존재하며 한 번 초깃값이 저장되면 변경할 수 없다
		(2) 선언 : static final 타입 상수 = 초깃값;
		(3) 특징
			a) 관례 : 상수 이름은 모두 대문자로 작성해준다
			b) 관례 : 서로 다른 단어가 혼합도니 이름이라면 '_'로 단어들을 연결해준다
```

### 6) 패키지와 접근 제한자

```
1. 패키지 선언
	1) 의미 : 클래스를 작성할 때 해당 클래스가 어떤 패키지에 속할 것인지를 선언하는 것
	2) 방법 : package 상위패키지.하위패키지.클래스;
2. import문
	1) 의미 : 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있다면 import 문을 사용해 해당 패키지의 클래스 또는 인터페이스를 사용할 것임을 알려주게 된다
    2) 방법 : import 상위패키지.하위패키지.클래스이름;
    3) 특징
    	(1) import문의 갯수는 제한이 없고 얼마든지 추가할 수 있다
    	(2) 상위 패키지를 import 했다고 해서 하위 패키지까지 import 되는 것은 아니다
3. 접근 제한자, access modifier
	1) 의미 : 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의 접근을 제한하기 위해 사용한다
	2) 종류
		(1) public : 외부 클래스가 자유롭게 사용할 수 있게 한다
		(2) protected : 같은 패키지 또는 자식 클래스 사용할 수 있게 한다
		(3) private : 외부에서 사용할 수 없도록 한다
		(4) default : 같은 패키지에 소속된 클래스에서만 사용할 수 있도록 한다
4. 클래스 접근 제한
	1) 의미 : 클래스를 선언할 때 해당 클래스를 같은 패키지 내에서만 사용할 것인지 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지 결정하는 것
	2) 종류
		(1) default
			a) 의미 : 같은 패키지에서는 아무런 제한 없이 사용할 수 있지만 다른 패키지에서는 사용할 수 없도록 제한된다
			b) 선언 : class 클래스이름{...}
		(2) public
			a) 의미 : 같은 패키지뿐만아니라 다른 패키지에서도 아무런 제한없이 사용할 수 있다
			b) 선언 : public class 클래스이름{...}
5. 생성자의 접근 제한
	1) 의미 : 접근 제한의 종류에 따라 생성자의 호출 가능 여부가 달라진다
	2) 종류
		(1) public : 아무런 제한 없이 생성자를 호출할 수 있다
		(2) protected : 같은 패키지에 속하는 클래스에서 생성자를 호출할 수 있도록 한다. 다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 생성자를 호출할 수 있다
		(3) default : 같은 패키지에서는 아무런 제한 없이 생성자를 호출할 수 있다. 다른 패키지에서는 생성자를 호출할 수 없다
		(4) private : 어떤 패키지이건 상관없이 생성자를 호출 할 수 없다. 오로지 클래스 내부에서만 생성자를 호출해 객체를 생성할 수 있다.
6. 필드와 메소드의 접근 제한
	1) 의미 : 필드와 메소드를 선언할 때 해당 필드와 메소드를 클래스 내부에서만 사용할 것인지 아니면 패키지 내에서 사용할 것인지, 다른 패키지에서도 사용할 것인지를 결정하는 것
	2) 종류
		(1) public : 모든 패키지에서 아무런 제한 없이 필드와 메소드를 사용할 수 있다
		(2) protected : 같은 패키지에 속하는 클래스에서 필드와 메소드를 사용할 수 있도록 설정한다. default와 다르게 다른 패키지에 속한 클래스가 해당 클래스의 자식 클래스라면 필드와 메소드를 사용할 수 있다
		(3) default : 같은 패키지에선 아무런 제한 없이 필드와 메소드를 사용할 수 있으나 다른 패키지에서는 필드와 메소드를 사용할 수 없다
		(4) private : 어떤 패키지이건 상관없이 필드와 메소드를 사용하지 못한다. 오로지 클래스 내부에서만 사용할 수 있다
7. Getter & Setter
	1) setter : 필드는 외부에서 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 필드에 접근하도록 유도한다. setter 메소드는 매개값을 검증해서 유효한 값만 객체의 필드로 저장한다
	2) getter : 필드값을 직접 사용하면 부적절한 경우도 있으므로 getter 메소드로 필드값을 가공한 후 외부로 전달한다
```

## 7. 상속

### 1) 상속

```
1. 클래스 상속
	1) 선언 : class 자식클래스 extends 부모클래스{필드 생성자 메소드}
	2) 특징
		(1) 여러 개의 부모 클래스를 상속할 수 없다
		(2) 부모 클래스에서 private 접근 제한을 갖는 필드와 메소드는 상속 대상에서 제외된다. 만약 부모 클래스와 자식 클래스가 다른 패키지에 존재하면 default 접근 제한을 갖는 필드와 메소드도 상속 대상에서 제외된다
2. 부모 생성자 호출
	1) 선언 : super(매개값,...)
	2) 특징
		(1) 매개값의 타입과 일치하는 부모 생성자를 호출한다
		(2) 반드시 자식 생성자의 첫 줄에 위치해야 한다
		(3) 부모 생성자에 기본 생성자가 없고 매개 변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자 호출을 위해 super()를 명시적으로 호출해야한다
3. 메소드 재정의
	1) 의미 : 자식 클래스에서 부모 클래스를 가져다가 쓰는 경우, 상속된 일부 메소드를 수정해 사용해야 할 경우 사용하는 방법
	2) 방법 : @Override 부모클래스이름(매개변수){}
	3) 특징
		(1) 부모의 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수 목록)를 가져야 한다
		(2) 접근 제한을 더 강하게 재정의 할 수 없다. 단 반대로 접근 제한을 약하게 하는 것은 가능하다
		(3) 새로운 에외를 throws 할 수 없다
		(4) 자식 클래스에서 부모 클래스의 메소드를 재정의하게 되면 부모 클래스의 메소드는 숨겨지고 재정의된 자식 메소드만 사용된다
	4) 부모 메소드 호출
		(1) 의미 : 자식 클래스에서 재정의된 부모 클래스의 메소드를 호출해야 하는 상황에서 부모 메소드를 호출하는 방법
		(2) 방법 : super.부모메소드();
4. final 클래스와 메소드
	1) final 클래스
		(1) 의미 : 상속할 수 없는 클래스. 따라서 부모 클래스가 될 수 없으므로 자식 클래스를 만들 수 없다
		(2) 방법 : public final class 클래스이름{...}
	2) final 메소드
		(1) 의미 : 재정의 할 수 없는 메소드. 따라서 부모 크래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의 할 수 없다
		(2) 방법 : public final 리턴타입 메소드([매개변수,...]){...}
```

### 2) 타입 변환과 다형성

```
1. 다형성 : 사용 방법은 동일하지만 다양한 객체를 이요해서 다양한 실행결과가 나오도록 하는 성질. 다형성을 구현하기 위해서는 메소드 재정의와 타입 변환이 필요하다.
2. 자동 타입 변환 
	1) 의미 : 프로그램 실행 도중에 상속 관계에 있는 클래스 사이에서 자식 클래스가 부모 클래스 타입으로 자동 타입 변환된다.
	2) 형태 : 부모타입 변수 = 자식타입;
	3) 특징 : 부모타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다
3. 필드의 다형성 : 필드의 타입을 부모 타입으로 선언하면 다양한 자식 객체들이 저장될 수 있기 때문에 필드 사용 결과가 달라질 수 있다.
4. 매개 변수의 다형성 : 매개값으로 어떤 자식 객체가 제공되느냐에 따라 메소드의 실행결과가 다양해진다
5. 강제 타입 변환, casting
	1) 의미 : 자식 타입이 부모 타입으로 자동 타입 변환한 후 다시 자식 타입으로 변환할 때 부모타입을 자식 타입으로 강제 타입 변환한다
	2) 형태 : 자식타입 변수 = (자식타입) 부모타입;
	3) 특징 : 강제 타입 변환하면 부모에 선언된 필드와 메소드만 사용 가능하다는 제약 사항이 따른다
6. 객체 타입 확인
	1) 방법 : 객체 instanceof 타입
	2) 의미 : 객체가 타입의 인스턴스라면(타입으로 객체가 생성되었다면)	 true를 리턴하고 그렇지 않으면 false를 리턴한다
```

### 3) 추상 클래스

```
1. 추상 클래스 의미 : 실체 클래스가 공통적으로 가져야 할 필드와 메소드들을 정의해놓은 추상적인 클래스로 실체 클래스의 멤버를 통일하는 데 목적이 있다
2. 추상 클래스 용도
	1) 공통된 필드와 메소드의 이름 통일
	2) 실체 클래스 작성시 시간 절약
3. 추상 클래스 선언 : 클래스 선언에 abstract 키워드를 붙여 만든다.
4. 추상 클래스 특징
	1) new 연산자를 이용해 객체를 만들지 못한다
    2) 상속을 통해 자식 클래스만 만들 수 있다. 따라서 추상 클래스는 부모 클래스로만 사용된다
    3) 필드, 생성자, 메소드를 선언할 수 있다.
    4) 추상 클래스는 객체를 직접 생성해서 사용할 수 없다.
5. 추상 메소드와 재정의
	1) 추상 메소드 
		(1) 이유 : 추상 클래스 설계 시 하위 클래스가 반드시 실행 내용을 채우도록 강제하고 싶은 메소드가 있을 경우 해당 메소드를 추상 메소드로 선언한다
		(2) 선언 : [public | protected] abstract 리턴타입 메소드이름(매개변수,...)
```

## 8. 인터페이스

### 1) 인터페이스

```
1. 인터페이스, interface : 개발 코드와 객체가 서로 통신하는 접점 역할을 한다. 
2. 인터페이스를 두는 이유 : 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해 인터페이스를 사용한다. 따라서 인터페이스를 사용하면 개발 코드 측면에서 코드 변경없이 실행 내용과 리턴값을 다양화 할 수 있는 장점을 같게 된다
3. 인터페이스 선언
	1) 선언 방법 : [public] interface 인터페이스이름 {상수_필드 추상_메소드}
	2) 상수 필드
		(1) 선언 : [public static final] 타입 상수이름 = 값
		(2) 의미 : 인터페이스는 인스턴스 똔느 정적 필드는 선언할 수 없으나 상수 필드는 선언이 가능하다
	3) 추상 메소드
		(1) 선언 : [public abstract] 리턴타입 메소드이름(매개변수,...);
		(2) 의미 : 인터페이스를 통해 호출된 메소드는 최종적으로 객체에서 실행된다. 따라서 인터페이스 메소드는 실행 블록이 필요 없는 추상 메소드로 선언한다
4. 인터페이스 구현
	1) 구현 객체, implements object : 개발 코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다. 객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개타입, 리턴타입을 가진 구현 객체가 된다
	2) 구현 클래스 
		(1) 의미 : 구현 객체를 생성하는 클래스. 어디서건 이미 선언된 구현 클래스로 간단히 객체를 생성해서 사용해 재사용성을 높일 수 있다.
		(2) 선언 :  pulic class 구현클래스이름 implements 인터페이스이름A,B.. {}
```

### 2) 타입 변환과 다형성

```
1. 인터페이스의 다형성 : 프로그램 소스 코드는 변함이 없는데, 인터페이스를 사용해서 메소드를 호출하도록 코딩해 구현 객체를 매우 손쉽고 빠르게 교체하는 것
2. 자동 타입 변환, promotion
	1) 의미 : 구현 객체가 인터페이스 타입으로 변환되는 것
	2) 형태 : 인터페이스 변수 = 구현객체
3. 필드의 다형성
4. 매개변수의 다형성
5. 강제 타입 변환
6. 객체 타입 확인
```

## 9. 중첩 클래스와 중첩 인터페이스

### 1) 중첩 클래스와 중첩 인터페이스

```
1. 중첩 클래스, nested class
	1) 의미 : 클래스 내부에 선언한 클래스. 두 클래스의 멤버들이 서로 쉽게 접근할 수 있고 외부에서 불필요한 관계 클래스를 감춰 코드의 복잡성을 줄일 수 있다.
	2) 종류 : 클래스 내부에 선언되는 위치에 따라 분류
		(1) 멤버 클래스
			a) 인스턴스 멤버 클래스
				(a) 의미 : static 키워드 없이 중첩 선언된 클래스. 인스턴스 필드와 메소드만 선언이 가능하고 정적 필드와 메소드는 선언할 수 없다.
				(b) 선언 위치 : class A{class B{...}} : A 객체를 생성해야만 사용할 수 있는 B 클래스
			b) 정적 멤버 클래스
				(a) 의미 : static 키워드로 선언된 클래스. 모든 종류의 필드와 메소드를 선언할 수 있다.
				(b) 선언 위치 : class A{static class B{...}} : A클래스로 바로 접근할 수 있는 B 클래스
			c) 멤버 클래스 특징
				(a) 클래스나 객체가 사용 중이라면 언제든 재사용이 가능하다
 		(2) 로컬 클래스 
 			a) 의미 : 메소드를 실행할 때만 사용되고 메소드가 종료되면 없어진다.
 			b) 선언 위치 : class A{void method(){class B{...}} : method()가 실행될 때만 사용할 수 있는 B 클래스
 			c) 특징
 				(a) 메소드 내부에서만 사용되므로 접근 제한자 및 static을 붙일 수 없다
 				(b) 인스턴스 필드와 메소드만 선언할 수 있고 정적 필드와 메소드는 선언할 수 없다
 	3) 사용 제한
 		(1) 바깥 필드와 메소드에서 사용 제한
 			a) 인스턴스 멤버 클래스
 				(a) 바깥 클래스의 인스턴스 필드의 초깃값 : 객체 생성 가능
 				(b) 바깥 클래스의 인스턴스 메소드 : 객체 생성 가능
 				(c) 정적 필드의 초깃값 : 객체 생성 불가
 				(d) 정적 메소드 : 객체 생성 불가
 			b) 정적 멤버 클래스
            	(a) 바깥 클래스의 인스턴스 필드의 초깃값 : 객체 생성 가능
 				(b) 바깥 클래스의 인스턴스 메소드 : 객체 생성 가능
 				(c) 정적 필드의 초깃값 : 객체 생성 가능
 				(d) 정적 메소드 : 객체 생성 가능
 		(2) 멤버 클래스에서 사용 제한
 			a) 인스턴스 멤버 클래스 : 바깥의 모든 필드와 메소드에 접근 가능
 			b) 정적 멤버 클래스 : 정적 필드와 메소드에만 접근 가능
 		(3) 로컬 클래스에서 사용 제한 :로컬 클래시의 객체는 메소드 실행이 종료되면 없어지는 것이 일반적이지만 메소드가 종료되어도 계속 실행 상태로 존재하는 경우가 있다. 이런 경우 메소드의 매개 변수나 로컬 변수를 로컬 클래스에서 사용할 때 제한이 발생한다.
 	4) 중첩 클래스에서 바깥 클래스 참조 얻기 : 바깥_클래스이름.this.필드및메소드
 	
2. 중첩 인터페이스, nested interface
	1) 의미 : 클래스 내부에 선언한 인터페이스. 해당 클래스와 긴밀한 관계를 맺는 구현 클래스를 만들 수 있다.
```

### 2) 익명 객체

```
1 익명 객체, anonymous : 어떤 클래스를 상속하거나 인터페이스를 구현해 만든 이름이 없는 객체
2. 익명 자식 객체 생성
	1) 의미 : 자식 클래스가 재사용되지 않고, 오로지 특정 위치에서 사용하는 경우에 익명 자식 객체를 생성해서 사용한다
	2) 방법 : 부모클래스 [필드|변수] = new 부모클래스(매개값,...){필드 메소드};
3. 익명 구현 객체 생성
	1) 의미 : 구현 클래스가 재사용되지 않고 오리지 특정 위치에서 사용하는 경우 익명 구현 객체를 생성해서 사용한다
	2) 방법 : 인터페이스 [필드|변수] = new 인터페이스(){인터페이스에 선언된 모든 추상 메소드의 실체 메소드 선언,  필드, 메소드}
```

## 10. 예외 처리

### 1) 예외 클래스

```
1. 예외, exception : 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩을 ㅗ인해 발생하는 프로그램 오류

2. 예외의 종류
	1) 일반 예외, exception : 컴파일러 체크 예외, Runtime Exception의 하위 클래스가 아니다. 자바 소스를 컴파일하는 과정에서 해당 예외 처리 코드가 있는 지 검사한다. 예외 처리 코드가 없다면 컴파일 오류가 발생한다
	2) 실행 예외, runtime exception : 컴파일러 넌 체크 예외, Runtime Exception의 하위 클래스. 실행 시 예측 할 수 없는 오류가 갑자기 발생하는 오류로서 컴파일하는 과정에서 예외 처리 코드가 있는지 검사하지 않는다

3. 실행 예외 : 해당 예외 발생시 프로그램은 바로 종료된다
	1) java.lang.NullPointerException : 객체 참조가 없는 상태, 즉 null 값을 갖는 참조 변수로 객체 접근 연산자인 도트(.)를 사용했을 때 발생한다
	2) java.lang.ArrayIndexOutOfBoundsException : 배열에서 인덱스 범위를 초과할 경우 발생하는 예외
	3) java.lang.NumberFormateException : 포장 클래스의 정적 메소드인 parseX() 메소드를 이용해 매개값인 문자열이 숫자로 변환 될 수 없을 때 발생하는 예외
	4) java.lang.ClassCastException : 타입 변환이 발생할 수 없는 경우 발생하는 예외. 타입 변환이 되는지 확인하기 위해서는 instanceof 연산자를 사용하면 된다
```

### 2) 예외 처리

```
1. try-catch-finally
	1) 의미 : 생성자 내부와 메소드 내부에서 작성되어 일반 예외와 실행 예외가 발생할 경우 예외 처리를 할 수 있도록 한다
	2) 구조 : try{try 내부 코드} catch(예외클래스 e){예외 처리 코드} finally{항상 실행되는 코드}
	3) 해석 : try 내부 코드 실행 도중 예외가 발생하지 않으면 곧장 finally 구문으로 넘어간다. 하지만 예외가 발생하는 경우 catch 구문 실행 후 finally 구문으로 넘어간다. 
	4) 특징
		(1) try 구문과 catch 구문에서 return문을 사용하더라도 finally 블록은 항상 실행된다
		(2) try 구문에서 예외 발생시 즉시 실행을 멈추고 catch 구문으로 이동하여 예외 처리 코드를 실행한다
		(3) finally 구문은 생략 가능하다
		
2. throws
	1) 의미 : 메소드 선언부 끝에 작성되어 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘기는 역할을 한다
	2) 선언 : 리턴타입 메소드이름(매개변수,...) throws Exception or 예외클래스1, 예외 클래스2,...{}
	3) 특징
		(1) throws 키워드가 붙어 있는 메소드는 반드시 try 블록 내에서 호출되어야 한다
```

## 11. 기본 API 클래스

### 1) java.lang 패키지

```
1. java.lang 패키지에 속하는 주요 클래스와 용도
	1) Object : 자바 클래스의 최상위 클래스로 사용
	2) System : 표준 입출력 장치로 사용하거나 자바 가상 기계를 종료할 때 사용
	3) Class : 클래스를 메모리로 로딩할 때 사용
	4) String : 문자열을 저장하고 여러 가지 정보를 얻을 때 사용
	5) Wrapper : 기본 타입의 데이터를 갖는 객체를 만들 때 사용
	6) Math : 수학 함수를 이용할 때 사용
	
2. Java API document
	1) 의미 : Java 표준 API 중 원하는 API 정보를 제공
	2) 주소 : https://docs.oracle.com/en/java/javase/11/docs/api/index.html
	
3. Object 클래스
	1) equals()
		(1) 용도 : 비교 연산자 '=='와 동일한 용도. 두 객체가 동일한 객체인 경우 true를 리턴하며, 그렇지 않으면 false를 리턴한다
		(2) 용법 : public boolean equals(Object obj){}
	2) hashCode()
		(1) 용도 : 객체를 식별하는 하나의 정수값
	3) toString()
		(1) 용도 : '클래스이름@16진수_해시코드'로 구성된 객체의 문자 정보 리턴.

4. System 클래스
	1) exit(int 매개값)
		(1) 용도 : 강제적으로 현재 실행하고 있는 프로세스를 강제 종료시킨다
	2) currentTimeMillis(), nanoTime()
		(1) 용도 : 컴퓨터의 시게로부터 현재 시간을 읽어 밀리세컨드와 나노 세컨드 단위의 long값을 리턴한다

5. Class 클래스
	1) getClass(), forName()
		(1) 의미 : class 객체를 얻는 방법
		(2) 객체 없이 클래스 이름만 가지고 class 객체를 얻는 방법
			a) 클래스로부터 class 객체를 얻는 방법
				(a) Class clazz = 클래스이름.class
				(b) Class clazz = Class.forName("패키지..클래스이름")
			b) 객체로 부터 class 객체를 얻는 방법
				(a) Class clazz = 참조변수.getClass()
		(3) 객체가 이미 생성되어 있는 경우 class 객체를 얻는 방법
			a) Class clazz = String.class;
			b) Class clazz = class.forName("java.lang.String");
			c) Class clazz = str.getClass();

6. String 클래스
	1) String 생성자
	2) String 메소드
		(1) .charAt(int number) :매개값으로 주어진 인덱스의 문자를 리턴한다
        (2) .equals() : 두 string 객체의 문자열 비교
        (3) .getBytes() : 네트워크로 문자열을 전송하거나 문자열을 암호화할 경우 등에 사용하기 위해 문자열을 바이트 배열로 변환
        (4) .indxeOf() : 매개값으로 주어진 문자열이 시작되는 인덱스 리턴
        (5) .length() : 문자열의 길이를 리턴
        (6) .replace("첫번째 매개값", "두번째 매개값") : 첫 번째 매개값인 문자열을 찾아, 두 번째 매개값인 문자열로 대치한 새로운 문자열을 생성하고 리턴
        (7) .substring(시작인덱스값, 종료인덱스값) : 주어진 인덱스에서 문자열 추출
        (8) .toLowerCase(), toUpperCase() : 문자열을 모두 대소문자로 변경한 후 리턴
        (9) .trim() : 문자열의 앞뒤 공백을 제거한 새로운 문자열을 생성하고 리턴
        (10) .valueOf() : 기본 타입의 값을 문자열로 변환
        
7. Wrapper 클래스
	1) wrapper 객체 : 기본 타입의 값을 갖는 객체이다. 포장하기 있는 기본 타입 값은 외부에서 변경할 수 없다
	2) Boxing & Unboxing
		(1) Boxing : 기본 타입의 값을 포장 객체로 만드는 과정
		(2) Unboxing : 포장 객체에서 기본 타입의 값을 얻어내는 과정
	3) 자동 Boxing & Unboxing
		(1) 자동 Boxing : 포장 클래스 타입에 기본값이 대입될 경우 발생
		(2) 자동 Unboxing : 기본 타입에 포장 객체가 대입되는 경우 연산에서 발생
	4) .parse기본타입이름 : 문자열을 기본 타입 값으로 변환하는 정적 메소드
	
8. Math 클래스
	1) abs : 절대값
	2) ceil : 올림값
	3) floor : 내림값
	4) max : 최댓값
	5) min : 최소값
	6) random : 랜덤값
	7) rint : 가까운 정수의 실수값
	8) round : 반올림값
```

### 2) java.util 패키지

```
1. Date 클래스
	1) 의미 : 특정 시점의 날짜를 표현하는 클래스
	
2. Calendar 클래스
	1) 의미 : 달력을 표현한 클래스. 추상 클래스이므로 new 연ㅅ나자를 사용해 인스턴스를 생성할 수 없다.
```

